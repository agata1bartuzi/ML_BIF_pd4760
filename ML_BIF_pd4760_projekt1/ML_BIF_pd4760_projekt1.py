# -*- coding: utf-8 -*-
"""ML_BIF_pd4760_projekt1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cg5FUDPJDyL7OtGn2NmZFSjdbhx-Wupg
"""

import pandas as pd

#Odczytanie danych
data = pd.read_csv("/content/dane_projekt1.csv", index_col='Gene_ID')

#Opis danych
print(f"Kolumny:\n{data.columns}")
print(f"Rozmiar:\n{data.shape}")
print(f"Typy danych:\n{data.dtypes}")
print(f"HEAD:\n{data.head()}")

# Ilosc probek w kazdej z klas
print(f"Kategorie genow:\n{data['Gene_Function'].value_counts()}")
data.sort_values(by=['Gene_Function'])

# Czyszczenie danych
#Informacja o wartosciach brakujacych
print(f"Wartości brakujące:\n{data.isna().sum()}")

#Usuniecie rzedow z brakujacymi danymi
data_clear = data.dropna()

#Sprawdzenie czy wartosci brakujace zostaly usuniete
print(f"Wartości brakujące:\n{data_clear.isna().sum()}")

#Lub zastapienie brakujacych wartosci srednia dla danego rzedu
numeric_cols = data.select_dtypes(include=['float64', 'int64'])
data_clear_row_mean = data.apply(lambda row: row.fillna(numeric_cols.loc[row.name].mean()), axis=1)

#Sprawdzenie czy wartosci brakujace zostaly zastapione
print(f"Wartości brakujące:\n{data_clear_row_mean.isna().sum()}")

# Redukcja wielowymiarowosci danych
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap
from sklearn.datasets import make_classification
from sklearn.preprocessing import StandardScaler, RobustScaler

df = data_clear_row_mean

X = df.drop(['Gene_Function'], axis=1)

# Kodowanie opisu funkcji
from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
y_encoded = le.fit_transform(df['Gene_Function'])
y = y_encoded

#Standaryzacja
scaler = RobustScaler()
X_scaled = scaler.fit_transform(X)

# Zbalansowanie klas
from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_scaled, y_encoded)

# PCA - analiza głównych składowych
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)
print("PCA 2 komponenty:\n", X_pca[:2])

# Wizualizacja

plt.figure(figsize=(8, 6))
plt.scatter(X_pca[:, 0], X_pca[:, 1], c=y_resampled, cmap='coolwarm', s=40)
plt.xlabel("Składowa 1")
plt.ylabel("Składowa 2")
plt.title("Redukcja wymiarowości danych RNA-seq (PCA: 2D)")
plt.colorbar(label="Zakodowana funkcja genu")
plt.tight_layout()
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay

# Model predykcji funkcji genu - Las losowy

# Podział na zbiór treningowy i testowy
X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.3, random_state=42)

# Trenujemy las losowy
forest_model = RandomForestClassifier(n_estimators=100, random_state=42)
forest_model.fit(X_train, y_train)

# Predykcja
y_pred_forest = forest_model.predict(X_test)

# Ocena
print("Las losowy - Accuracy:", accuracy_score(y_test, y_pred_forest))
print("Classification Report:\n", classification_report(y_test, y_pred_forest))

# Macierze błędów
fig, ax = plt.subplots(figsize=(12, 5))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred_forest, ax=ax, display_labels=le.inverse_transform(forest_model.classes_))
ax.set_title("Las losowy")

plt.tight_layout()
plt.show()

# Podsumowanie
'''
Ocena dokladnosci predykcji modelu ("Accuracy") na poziomie 0.45 wskazuje na niedostateczne zbalansowanie klas
w tym projekcie.

Wspolczynnik precyzji ("Precision") wskazuje, ze sposrod genow, ktore zostaly zaklasyfikowane jako kodujace bialka 
enzymatyczne ("enzyme") 71% faktycznie nimi bylo. Dla kolejnych klas wynik ten prezentuje sie na bardzo niskim poziomie:
jedynie 0.29% genow zakwalifikowanych jako kodujace bialka receptorowe ("receptor"), 0.33% genow bialek strukturalnych
("structural protein") i regulatorow transkrypcji ("transcription factor") zostalo zaklasyfikowane poprawnie.

Wynik oceny czulosci ("Recall") wskazal natomiast, ze w przypadku klasy "enzyme" sposrod wszystkich genow tej klasy
83% zostaly pozytywnie do niej zakwalifikowane - 1 sposrod 6 probek zostala zakwalifikowana do klasy "receptor", 
co obrazuje graficzne przedstawienie "Confusion Matrix". Jedynie polowa genow z klasy "receptor" zostala poprawnie 
rozpoznana (pozostale 2 z 4 probek byly mylone z klasami "structural protein" i "transcription factor"), sposrod
genow dwoch ostatnich klas tylko 1/4 byla przez model poprawnie rozpoznawana, przy czym najslabiej odrozniajaca sie
zdaje sie byc klasa "structural protein", gdyz geny nalezace do niej byly mylone ze wszystkimi pozostalymi klasami.

Podsumowujac,  kategoryzacja do zaledwie jednej z czterech klas osiaga zadowalajce wyniki oceny.
Klasa genow kodujacych bialka enzymatyczne ("enzyme") wyraznie rozni sie od pozostalych klas i jest
ona efektywnie rozpoznawana przez model Lasu Losowego. Najslabsze wyniki predykcji model osiaga probujac
rozpoznac geny nalezace do klasy "structural protein". 

Dodanie wiekszej liczby badanych genow do tego eksperymentu w celu zrownowazenia liczebnosci probek w klasach, mogloby
efektywnie poprawic wynik predykcji.
'''
