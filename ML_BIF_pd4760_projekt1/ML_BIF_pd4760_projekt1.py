# -*- coding: utf-8 -*-
"""ML_BIF_pd4760_projekt1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cg5FUDPJDyL7OtGn2NmZFSjdbhx-Wupg
"""

import pandas as pd

#Odczytanie danych
data = pd.read_csv("/content/dane_projekt1.csv", index_col='Gene_ID')

#Opis danych
print(f"Kolumny:\n{data.columns}")
print(f"Rozmiar:\n{data.shape}")
print(f"Typy danych:\n{data.dtypes}")
print(f"HEAD:\n{data.head()}")

# Ilosc probek w kazdej z klas
print(f"Kategorie genow:\n{data['Gene_Function'].value_counts()}")
data.sort_values(by=['Gene_Function'])

# Czyszczenie danych
#Informacja o wartosciach brakujacych
print(f"Wartości brakujące:\n{data.isna().sum()}")

#Usuniecie rzedow z brakujacymi danymi
data_clear = data.dropna()

#Sprawdzenie czy wartosci brakujace zostaly usuniete
print(f"Wartości brakujące:\n{data_clear.isna().sum()}")

#Lub zastapienie brakujacych wartosci srednia dla danego rzedu
numeric_cols = data.select_dtypes(include=['float64', 'int64'])
data_clear_row_mean = data.apply(lambda row: row.fillna(numeric_cols.loc[row.name].mean()), axis=1)

#Sprawdzenie czy wartosci brakujace zostaly zastapione
print(f"Wartości brakujące:\n{data_clear_row_mean.isna().sum()}")

# Redukcja wielowymiarowosci danych
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap
from sklearn.datasets import make_classification
from sklearn.preprocessing import StandardScaler, RobustScaler

df = data_clear_row_mean

X = df.drop(['Gene_Function'], axis=1)

# Kodowanie opisu funkcji
from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
y_encoded = le.fit_transform(df['Gene_Function'])
y = y_encoded

#Standaryzacja
scaler = RobustScaler()
X_scaled = scaler.fit_transform(X)

# Zbalansowanie klas
from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_scaled, y_encoded)

# PCA - analiza głównych składowych
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)
print("PCA 2 komponenty:\n", X_pca[:2])

# Wizualizacja

plt.figure(figsize=(8, 6))
plt.scatter(X_pca[:, 0], X_pca[:, 1], c=y_resampled, cmap='coolwarm', s=40)
plt.xlabel("Składowa 1")
plt.ylabel("Składowa 2")
plt.title("Redukcja wymiarowości danych RNA-seq (PCA: 2D)")
plt.colorbar(label="Zakodowana funkcja genu")
plt.tight_layout()
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay

# Model predykcji funkcji genu - Las losowy

# Podział na zbiór treningowy i testowy
X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.3, random_state=42)

# Trenujemy las losowy
forest_model = RandomForestClassifier(n_estimators=100, random_state=42)
forest_model.fit(X_train, y_train)

# Predykcja
y_pred_forest = forest_model.predict(X_test)

# Ocena
print("Las losowy - Accuracy:", accuracy_score(y_test, y_pred_forest))
print("Classification Report:\n", classification_report(y_test, y_pred_forest))

# Macierze błędów
fig, ax = plt.subplots(figsize=(12, 5))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred_forest, ax=ax, display_labels=le.inverse_transform(forest_model.classes_))
ax.set_title("Las losowy")

plt.tight_layout()
plt.show()

# Podsumowanie
'''
Ocena dokladnosci predykcji modelu ("Accuracy") na poziomie 0.45 wskazuje na niedostateczne zbalansowanie klas
w tym projekcie. Kategoryzacja do zaledwie jednej z czterech klas osiaga zadowalajce wyniki oceny.
'''